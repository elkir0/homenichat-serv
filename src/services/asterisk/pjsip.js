/**
 * PJSIP Configuration Module
 * Manages PJSIP endpoints, auth, and AOR for WebRTC extensions
 */

const fs = require('fs');
const crypto = require('crypto');
const logger = require('../../../utils/logger');
const {
    PJSIP_ENDPOINTS_CONF,
    PJSIP_CUSTOM_CONF,
    WEBRTC_TRANSPORT_NAME,
    WEBRTC_DEFAULT_CODECS,
    EXTENSION_MIN,
    EXTENSION_MAX,
} = require('./constants');

/**
 * Generate random password
 */
function generateSecret(length = 16) {
    return crypto.randomBytes(length).toString('hex').slice(0, length);
}

/**
 * Get the PJSIP config file path (prefer pjsip_endpoints.conf, fallback to pjsip_custom.conf)
 */
function getConfigPath() {
    if (fs.existsSync(PJSIP_ENDPOINTS_CONF)) {
        return PJSIP_ENDPOINTS_CONF;
    }
    return PJSIP_CUSTOM_CONF;
}

/**
 * Read current PJSIP configuration
 */
function readConfig() {
    const configPath = getConfigPath();
    try {
        if (fs.existsSync(configPath)) {
            return fs.readFileSync(configPath, 'utf8');
        }
    } catch (error) {
        logger.error('[PJSIP] Error reading config:', error.message);
    }
    return '';
}

/**
 * Write PJSIP configuration
 */
function writeConfig(content) {
    const configPath = getConfigPath();
    try {
        // Backup existing config
        if (fs.existsSync(configPath)) {
            fs.copyFileSync(configPath, `${configPath}.bak`);
        }
        fs.writeFileSync(configPath, content);
        logger.info(`[PJSIP] Config written to ${configPath}`);
        return true;
    } catch (error) {
        logger.error('[PJSIP] Error writing config:', error.message);
        return false;
    }
}

/**
 * Check if extension exists in config
 */
function extensionExists(extension) {
    const content = readConfig();
    const regex = new RegExp(`\\[${extension}\\]`, 'm');
    return regex.test(content);
}

/**
 * Generate PJSIP endpoint configuration for WebRTC
 */
function generateEndpointConfig(data) {
    const {
        extension,
        secret,
        displayName,
        codecs = WEBRTC_DEFAULT_CODECS,
        transport = WEBRTC_TRANSPORT_NAME,
        context = 'internal',
    } = data;

    const codecString = Array.isArray(codecs) ? codecs.join(',') : codecs;

    return `
; Extension ${extension} - ${displayName || extension}
; Generated by Homenichat - ${new Date().toISOString()}

[${extension}](webrtc-endpoint-template)
type=endpoint
context=${context}
disallow=all
allow=${codecString}
transport=${transport}
webrtc=yes
direct_media=no
aors=${extension}
auth=${extension}
callerid="${displayName || extension}" <${extension}>
dtls_auto_generate_cert=yes

[${extension}]
type=aor
max_contacts=5
remove_existing=yes
qualify_frequency=30

[${extension}]
type=auth
auth_type=userpass
username=${extension}
password=${secret}
`;
}

/**
 * Create a new PJSIP extension
 */
async function createExtension(data, amiConnection = null) {
    const {
        extension,
        displayName,
        secret = generateSecret(),
        codecs,
        context = 'internal',
    } = data;

    if (!extension || !/^\d{4}$/.test(extension)) {
        throw new Error('Extension must be 4 digits');
    }

    if (extensionExists(extension)) {
        throw new Error(`Extension ${extension} already exists`);
    }

    // Generate config
    const endpointConfig = generateEndpointConfig({
        extension,
        secret,
        displayName,
        codecs,
        context,
    });

    // Append to config file
    const currentConfig = readConfig();
    const newConfig = currentConfig + endpointConfig;

    if (!writeConfig(newConfig)) {
        throw new Error('Failed to write PJSIP configuration');
    }

    // Reload PJSIP module if AMI connection available
    if (amiConnection?.authenticated) {
        try {
            await amiConnection.reloadModule('res_pjsip');
            logger.info(`[PJSIP] Extension ${extension} created and PJSIP reloaded`);
        } catch (error) {
            logger.warn('[PJSIP] Failed to reload PJSIP module:', error.message);
        }
    }

    return {
        extension,
        secret,
        displayName,
        context,
        created: true,
    };
}

/**
 * Delete a PJSIP extension
 */
async function deleteExtension(extension, amiConnection = null) {
    if (!extensionExists(extension)) {
        return { deleted: false, message: 'Extension not found' };
    }

    const currentConfig = readConfig();

    // Remove extension sections (endpoint, aor, auth)
    const lines = currentConfig.split('\n');
    const newLines = [];
    let skipSection = false;
    let currentSection = null;

    for (const line of lines) {
        const sectionMatch = line.match(/^\[(\d+)\](\(.*\))?$/);

        if (sectionMatch) {
            const sectionExt = sectionMatch[1];
            if (sectionExt === extension) {
                skipSection = true;
                currentSection = extension;
                continue;
            } else {
                skipSection = false;
                currentSection = sectionExt;
            }
        }

        // Skip comment lines associated with the extension
        if (line.startsWith('; Extension ' + extension)) {
            skipSection = true;
            continue;
        }

        if (!skipSection) {
            newLines.push(line);
        }
    }

    // Remove empty lines at section boundaries
    const cleanedConfig = newLines.join('\n').replace(/\n{3,}/g, '\n\n').trim() + '\n';

    if (!writeConfig(cleanedConfig)) {
        throw new Error('Failed to write PJSIP configuration');
    }

    // Reload PJSIP module if AMI connection available
    if (amiConnection?.authenticated) {
        try {
            await amiConnection.reloadModule('res_pjsip');
            logger.info(`[PJSIP] Extension ${extension} deleted and PJSIP reloaded`);
        } catch (error) {
            logger.warn('[PJSIP] Failed to reload PJSIP module:', error.message);
        }
    }

    return { deleted: true };
}

/**
 * Update extension secret (password)
 */
async function updateExtensionSecret(extension, newSecret, amiConnection = null) {
    if (!extensionExists(extension)) {
        throw new Error(`Extension ${extension} not found`);
    }

    const currentConfig = readConfig();

    // Find and replace password line in auth section
    const lines = currentConfig.split('\n');
    const newLines = [];
    let inAuthSection = false;
    let foundAuth = false;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Check for auth section start
        if (line.match(new RegExp(`^\\[${extension}\\]$`))) {
            // Check if next line has type=auth
            if (i + 1 < lines.length && lines[i + 1].includes('type=auth')) {
                inAuthSection = true;
            }
        }

        // Replace password in auth section
        if (inAuthSection && line.startsWith('password=')) {
            newLines.push(`password=${newSecret}`);
            foundAuth = true;
            inAuthSection = false;
            continue;
        }

        // End of section
        if (inAuthSection && line.startsWith('[')) {
            inAuthSection = false;
        }

        newLines.push(line);
    }

    if (!foundAuth) {
        throw new Error(`Auth section for extension ${extension} not found`);
    }

    if (!writeConfig(newLines.join('\n'))) {
        throw new Error('Failed to write PJSIP configuration');
    }

    // Reload PJSIP
    if (amiConnection?.authenticated) {
        try {
            await amiConnection.reloadModule('res_pjsip');
        } catch (error) {
            logger.warn('[PJSIP] Failed to reload after secret update:', error.message);
        }
    }

    return { updated: true, extension };
}

/**
 * Get next available extension number
 */
function getNextAvailableExtension() {
    const currentConfig = readConfig();
    const usedExtensions = new Set();

    const matches = currentConfig.matchAll(/^\[(\d{4})\]/gm);
    for (const match of matches) {
        usedExtensions.add(parseInt(match[1]));
    }

    for (let ext = EXTENSION_MIN; ext <= EXTENSION_MAX; ext++) {
        if (!usedExtensions.has(ext)) {
            return String(ext);
        }
    }

    throw new Error('No available extension numbers');
}

/**
 * Get extension status via AMI
 */
async function getExtensionStatus(extension, amiConnection) {
    if (!amiConnection?.authenticated) {
        return { status: 'unknown', message: 'AMI not connected' };
    }

    try {
        const response = await amiConnection.sendAction({
            action: 'PJSIPShowEndpoint',
            Endpoint: extension,
        });

        return {
            extension,
            registered: response.DeviceState === 'NOT_INUSE' || response.DeviceState === 'INUSE',
            deviceState: response.DeviceState,
            contacts: response.Contacts || 0,
        };
    } catch (error) {
        return {
            extension,
            registered: false,
            error: error.message,
        };
    }
}

/**
 * List all configured extensions
 */
function listExtensions() {
    const currentConfig = readConfig();
    const extensions = [];

    // Match endpoint sections
    const regex = /\[(\d{4})\]\(webrtc-endpoint-template\)[\s\S]*?callerid="([^"]*)"[^\[]*/g;
    let match;

    while ((match = regex.exec(currentConfig)) !== null) {
        extensions.push({
            extension: match[1],
            displayName: match[2] || match[1],
        });
    }

    return extensions;
}

module.exports = {
    generateSecret,
    getConfigPath,
    readConfig,
    writeConfig,
    extensionExists,
    generateEndpointConfig,
    createExtension,
    deleteExtension,
    updateExtensionSecret,
    getNextAvailableExtension,
    getExtensionStatus,
    listExtensions,
};
